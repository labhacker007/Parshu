# Security Review: `backend/app/admin/routes.py`

Scope: admin configuration management, secrets-at-rest approach, outbound “test connector” calls, and information disclosure via admin APIs.

## Findings (what to fix)

### 1) Sensitive-value encryption key is derived from `SECRET_KEY` (High)
**What I see**
- `get_encryption_key()` derives the Fernet key from `settings.SECRET_KEY[:32].ljust(32, '0')`.
- The same `SECRET_KEY` is also used for JWT signing (see auth code).

**Why it matters**
- Key reuse across cryptographic purposes is a security smell and complicates rotation.
- Truncation/padding reduces effective entropy if operators provide passphrase-like secrets.
- Rotating `SECRET_KEY` would break decryption of stored config values unless you build key rotation support.

**Fix**
- Introduce a dedicated encryption key, e.g. `CONFIG_ENCRYPTION_KEY`:
  - 32-byte urlsafe base64 key generated by `Fernet.generate_key()`
  - stored in a secret manager / Kubernetes Secret
- Optionally derive per-purpose keys from a master secret using HKDF (with distinct context strings).
- Add a key rotation story (support multiple active keys for decrypt, single for encrypt).

**Acceptance criteria**
- JWT signing secret and configuration-encryption secret are distinct.
- Secret rotation does not permanently brick stored encrypted values.

---

### 2) Decryption failure returns ciphertext “as-is” (Medium)
**What I see**
- `decrypt_value()` returns the input unchanged if decryption fails.

**Why it matters**
- Fail-open behavior can lead to confusing downstream behavior:
  - ciphertext may be used as an API key/password in connector tests
  - errors may leak to logs/UI

**Fix**
- Fail closed: return `None`/empty and surface a clear “cannot decrypt” status.
- Track encryption version/key-id with each stored secret so you can identify mismatches cleanly.

**Acceptance criteria**
- A decryption failure cannot cause connector tests to run with garbage secrets.

---

### 3) Admin “test configuration” endpoints are outbound-call surfaces (SSRF/scan) (Medium/High)
**What I see**
- `/admin/configurations/test/{category}` can trigger network calls (SMTP, Slack, GenAI provider checks) using admin-supplied hostnames/URLs.

**Why it matters**
- Even if admin-only, these endpoints can be abused after account takeover to scan internal network targets.
- They increase blast radius of SSRF-type bugs by design.

**Fix**
- Apply SSRF controls to any admin-configured URLs/hosts where feasible:
  - allowlist domains for outbound targets, or restrict to expected endpoints
  - block internal IP ranges unless explicitly intended
- Ensure errors returned to clients are sanitized (avoid returning raw `str(e)`).

**Acceptance criteria**
- Admin tests cannot be used as a general-purpose internal port scanner.

---

### 4) Error detail leakage in admin API responses (Medium)

**What was happening**
- Multiple `/admin/*` endpoints returned raw exception strings to clients via:
  - `HTTPException(detail=f"... {str(e)}")`
  - JSON payloads like `"error": str(e)` / `"reason": str(e)`

**Why it matters**
- Exception strings often include sensitive implementation details:
  - internal URLs/hosts, file paths, SQL snippets, library versions
  - occasionally secrets (if upstream exceptions include them)
- Even if admin-only, this increases blast radius after account takeover and makes exploitation easier.

**Fix**
- Sanitized admin responses to avoid reflecting raw exception text:
  - replaced `detail=...{str(e)}...` with fixed, non-sensitive messages
  - replaced `"error": str(e)` / `"reason": str(e)` with generic error codes/messages
  - kept detailed context in server-side logs via `logger.error(..., error=str(e))`

**Validation**
- Added regression test: `backend/tests/test_admin_error_leakage.py`.
- Full backend test suite: `backend/.venv310/Scripts/python -m pytest -q` (passes as of 2026-02-02).

---

### 5) Page-access RBAC endpoint returned incorrect permission sets (Medium)

**What was happening**
- `/admin/rbac/pages/role/{role}` was returning API permissions as `granted_permissions` / `all_permissions` for each page.
- The frontend Page Access Manager expects *page-level* permission keys (from `page_permissions.py`) so it can show correct checkboxes and access state.

**Fix**
- `/admin/rbac/pages/role/{role}` now returns, per page:
  - `all_permissions`: that page’s permission keys
  - `granted_permissions`: the granted subset (defaults, or persisted page permissions when present)

**Validation**
- Regression test: `backend/tests/test_permissions_endpoints.py`.
